

function SDISpectrum::init, restore_struc = restore_struc, data = data, zone_settings = zone_settings, $
						    file_name_format=file_name_format

	;\\ Generic Settings
		self.need_timer = 0
		self.need_frame = 1
		self.manager 	= data.manager
		self.console 	= data.console
		self.palette	= data.palette
		self.obj_num 	= string(data.count, format = '(i0)')


	;\\ Do if no zone map settings
		if not keyword_Set(zone_settings) then begin
			zone_settings = 'default_zones.txt'
		endif

	;\\ Plugin Specific Settings
		self.nchann = data.nchann
		self.xdim = data.xdim
		self.ydim = data.ydim
		self.spectra = ptr_new(/alloc)
		self.zonemap = ptr_new(/alloc)
		self.phasemap = ptr_new(/alloc)
		self.accumulated_image = ptr_new(/alloc)
		self.rads = ptr_new(/alloc)
		self.secs = ptr_new(/alloc)
		self.zone_centers = ptr_new(/alloc)
		self.zonemap_boundaries = ptr_new(/alloc)
		self.wavelength = data.wavelength
		self.dll = self.console -> get_dll_name()
		self.spec_path = self.console -> get_spectra_path()
		if strmid(zone_settings, strlen(zone_settings)-4, 4) ne '.txt' then begin
			zone_settings = zone_settings + '.txt'
		endif
		if keyword_set(file_name_format) then self.file_name_format = file_name_format
		self.zone_settings = self.console -> get_zone_set_path() + zone_settings
		self.log = obj_new('XDILog', show_log = 0, prog_name = 'Spectrum @ '+string(self.wavelength,f='(f0.1)')+'nm', log_path = data.logging.log_directory, $
							enabled = data.logging.enable_logging, log_append = data.logging.log_append, header=data.header)

		if data.recover eq 1 then begin
			;\\ Saved settings
				xoff = restore_struc.geometry.xoffset
				yoff = restore_struc.geometry.yoffset
				xs 	= 552
				ys 	= 840
		endif else begin
			;\\ Default settings
				xoff = 0
				yoff = 0
				xs 	= 552
				ys 	= 840
		endelse


	;\\ Build the widgets
		base = widget_base(group_leader = data.leader, mbar = menu, xoff = xoff, yoff = yoff, $
						   title = 'SDI Spectrum ' + string(self.wavelength, f='(f0.1)') + 'nm', col=1)

		file_menu = widget_button(menu, value = 'File')

		font = 'TimesBold*22'
		font2 = 'TimesBold*18'

		draw = widget_draw(base, xs=552, ys=552, uname = 'Spectrum_'+self.obj_num+'_draw', /align_center)

		base_1 = widget_base(base, col=2)

			exp_draw = widget_draw(base_1, xs=552/2, ys=200, uname='Spectrum_'+self.obj_num+'_exp_draw', /align_center)
			bck_draw = widget_draw(base_1, xs=552/2, ys=200, uname='Spectrum_'+self.obj_num+'_bck_draw', /align_center)

		base_2 = widget_base(base, col = 1)
			chann_box = widget_text(base_2, value = 'Channel: ' + string(0, f='(i0)'), uname = 'Spectrum_'+self.obj_num+'_channel', font=font2)

		base_3 = widget_base(base, col = 3)
		start_but = widget_button(base_3, value = 'Start Scan', uval = {tag:'start_scan'}, font = font)
		stop_but  = widget_button(base_3, value = 'Stop Scan', uval = {tag:'stop_scan'}, font=font)
		finalize_but  = widget_button(base_3, value = 'Finalize Exposure', uval = {tag:'finalize_scan'}, font=font)


		file_menu2 = widget_button(file_menu, value = 'Capture Image (.PNG)', $
								   uval = {tag:'image_capture', $
								   		   id:[draw, exp_draw], $
								   		   name:['Spectrum', 'Spectrum ExpMeter'], $
								   		   type:'png'})
		file_menu3 = widget_button(file_menu, value = 'Capture Image (.JPG)', $
								   uval = {tag:'image_capture', $
								   		   id:[draw, exp_draw], $
								   		   name:['Spectrum', 'Spectrum ExpMeter'], $
								   		   type:'jpg'})


		self.id = base


		widget_control, self.id, /realize

	;\\ Set the phasemap
		self -> set_phasemap, failed
		if failed eq 1 then return, 0

	;\\ Open/reopen a netcdf file to save spectra
		spec_save_info = self.console -> get_spec_save_info(self.nrings)
		header = self.console -> get_header_info()

		if self.file_name_format eq '' then begin
			file_name_format = ''
			xvaredit, file_name_format, name = 'Enter a filename/format string:', group=self.id
		endif

		get_jd0_sec, jd0, sec
		filename = dt_tm_mk(jd0, sec, f=file_name_format)
		filename = strupcase(header.site_code) + '_' + filename

		self.filename = filename

		spec_save_info.wavelength   = self.wavelength
		spec_save_info.zone_radii   = *self.rads
		spec_save_info.zone_sectors = *self.secs

		if file_test(self.spec_path + filename) eq 1 then begin
			self.log -> update, 'REopening ' + self.spec_path + filename
			Write_Spectra_NetCDF, 0, *self.spectra, 0, 0, 0, 0, fname=self.spec_path + filename, return_id=return_id, $
					  header=header, data=spec_save_info, /reopen
			self.file_id = return_id
		endif else begin
			self.log -> update, 'Opening ' + self.spec_path + filename
			Write_Spectra_NetCDF, 0, *self.spectra, 0, 0, 0, 0, /create, fname=self.spec_path + filename, return_id=return_id, $
					  header=header, data=spec_save_info
			self.file_id = return_id
		endelse


		return, 1

end


;\\ Start the procedure

pro SDISpectrum::start_scan, event

	if self.scanning ne 1 then begin

		w = self.wavelength
		while w eq 0.0 do begin
			if w eq 0.0 then begin
				xvaredit, w, name = 'Enter a wavelength in nanometres:', group=self.id
			endif
		endwhile
		self.wavelength = w

		;\\ Begin the scanner
			self.console -> scan_etalon, 'Spectrum (' + string(self.wavelength, f='(f0.1)') + ') obj:' + self.obj_num, $
							status = status, wavelength=self.wavelength,  /start_scan

			if status eq 'Scanner started' then begin
				self.scanning = 1
				self.log -> update, 'Started acquiring spectra'
			endif

	endif

end


;\\ Auto-start procedure

function SDISpectrum::auto_start, args

	if n_elements(args) ne 3 then return, 'Error: wrong # of arguments'

	self.auto = 1
	self.wavelength = float(args(0))


	;\\ Begin the scanner
		self.console -> scan_etalon, 'Spectrum (' + string(self.wavelength, f='(f0.1)') + ') obj:' + self.obj_num, $
						status = status, wavelength=self.wavelength,  /start_scan

		if status eq 'Scanner started' then begin
			self.scanning = 1
			self.log -> update, 'Started acquiring spectra'
		endif else begin
			;\\ Update the log
				self.log -> update, 'Scanner could not be started - auto-mode'
				return, 'Error: failed to start scanner'
		endelse

	return, 'Success'

end



;\\ Initializes the phasemap, zonemap and arrays

pro SDISpectrum::initializer


	;\\ Get the draw tv_id
		draw_id = widget_info(self.id, find_by_uname = 'Spectrum_'+self.obj_num+'_draw')
		widget_control, get_value = tv_id, draw_id


	;\\ Wrap the phasemap
		phasemap = *self.phasemap
		phasemap = phasemap mod self.nchann
		*self.phasemap = phasemap
		self.log -> update, 'Wrapped the phasemap'


	;\\ Make a zonemap
		READ_ZONE_SETTINGS:
		a=''
		b=''

		openr, file, self.zone_settings, /get_lun
			readf, file, a
			readf, file, b
		close, file
		free_lun, file

		resa = execute(a)
		resb = execute(b)

		if resa eq 0 or resb eq 0 then begin
			self.log -> update, 'Zonemap settings file caused an error: reverting to default_zones.txt'
			self.zone_settings = self -> get_zone_set_path() + 'default_zones.txt'
			goto, READ_ZONE_SETTINGS
		endif else begin
			self.log -> update, 'Zonemap file read successfully'
		endelse

		*self.rads = rads
		*self.secs = secs

	;\\ Get some console data
		self.nrings = n_elements(rads)
		spec_save_info = self.console -> get_spec_save_info(self.nrings)
		header = self.console -> get_header_info()


		cent = [spec_save_info.x_center, spec_save_info.y_center]

		nums = intarr(n_elements(secs))
		nums(0) = 0
		for n = 1, n_elements(secs) - 1 do begin
			nums(n) = total(secs(0:n-1))
		endfor

		zonemap = zonemapper(self.xdim, self.ydim, cent, rads, secs, nums)
		*self.zonemap = zonemap
		self.nzones = max(zonemap) + 1


		self.log -> update, 'Zone settings:'
		self.log -> update, 'Rads - ' + string(rads, f='("[",'+string(n_elements(rads),f='(i0)')+'(f0.2," "),"]")')
		self.log -> update, 'Secs - ' + string(secs, f='("[",'+string(n_elements(secs),f='(i0)')+'(i0,  " "),"]")')
		self.log -> update, 'Nums - ' + string(nums, f='("[",'+string(n_elements(nums),f='(i0)')+'(i0,  " "),"]")')

	;\\ Display the zonemap
		wset, tv_id
		loadct, 31, /silent
		tvscl, zonemap, (552-self.xdim)/2, (552-self.ydim)/2
		load_pal, self.palette

	;\\ Get the x,y positions of the zone centers for plotting
		zone_centers = intarr(self.nzones, 2)
		for zn = 0, self.nzones-1 do begin
			pts = where(zonemap eq zn, npts)
			ind = array_indices(zonemap, pts)
			zone_centers(zn,0) = (max(ind(0,*))+min(ind(0,*)))/2
			zone_centers(zn,1) = (max(ind(1,*))+min(ind(1,*)))/2
			xyouts, zone_centers(zn,0) + (552-self.xdim)/2, $
					zone_centers(zn,1) + (552-self.ydim)/2, $
					string(zn,f='(i0)'), /device, color=self.palette.black, align=.5
		endfor
		*self.zone_centers = zone_centers


	;\\ Get an array containing the indexes of the boundaries between zone cells

		zbounds = intarr(self.xdim, self.ydim)

		for x = 0, self.xdim - 2 do begin
		for y = 0, self.ydim - 1 do begin
			if (zonemap(x,y) - zonemap(x+1,y)) ne 0 then zbounds(x,y) = 1
		endfor
		endfor

		for x = 0, self.xdim - 1 do begin
		for y = 0, self.ydim - 2 do begin
			if (zonemap(x,y) - zonemap(x,y+1)) ne 0 then zbounds(x,y) = 1
		endfor
		endfor

		*self.zonemap_boundaries = zbounds

	;\\ Set up the spectra array
		*self.spectra = ulonarr(self.nzones, self.nchann)

;-------Discard any images accumulated in the camera while we set all this up:
;		resx = call_external(self.dll, 'uAbortAcquisition')
;		resx = call_external(self.dll, 'uFreeInternalMemory')
;		self.console -> zero_image
;		resx = call_external(self.dll, 'uStartAcquisition')

end



;\\ Frame event - makes a spectral accumulation

pro SDISpectrum::frame_event, image, channel
common spec_save, spec, zone, phase, acc_im

	now = systime(1)
	;\\ Get the draw tv_id
		chan_id = widget_info(self.id, find_by_uname = 'Spectrum_'+self.obj_num+'_channel')
		draw_id = widget_info(self.id, find_by_uname = 'Spectrum_'+self.obj_num+'_draw')
		widget_control, get_value = tv_id, draw_id

		widget_control, set_value = 'Channel: '+string(channel+1,f='(i0)'), chan_id

	if n_elements(acc_im) eq 0 then begin
	 		spec = *self.spectra
			zone = *self.zonemap
			phase = *self.phasemap
			*self.accumulated_image = ulonarr(self.xdim, self.ydim)
			acc_im = *self.accumulated_image
	endif

	if self.scanning eq 1 then begin

		nsteps = self.nchann

		if channel eq 0 and self.nscans eq 0 then begin
			self.scan_start_time = dt_tm_tojs(systime(/ut))
			;\\ Reset the accumulated image array
			*self.accumulated_image = ulonarr(self.xdim, self.ydim)
			;\\ Reset the signal noise history array
			self.signal_noise_history[*] = 0
			self.scan_background_history[*] = 0
	 		spec = *self.spectra
			zone = *self.zonemap
			phase = *self.phasemap
			acc_im = *self.accumulated_image
		endif

		self.channel_background_history[channel] = min(smooth(image, 40, /edge))

		acc_im = acc_im + image
		sizes = fix([self.xdim, self.ydim, self.nzones, self.nchann])
		;stop ;###########################
		res = call_external(self.dll, 'uUpdateSpectra', long(image), fix(phase), zone, spec, fix(channel), sizes, value=bytarr(6))

;print, 'Done for spex processing: ', systime(1) - now
		;print, 'Reached spex 1:', systime()
		if channel eq (nsteps-1) then begin

			self.nscans = self.nscans + 1
			*self.accumulated_image = acc_im
			*self.spectra = spec


			;\\ Check for sufficient signal (exposure time) and generate a signal/noise estimate
				signal = 0UL
				bgnd   = 0UL
				zone_power = fltarr(self.nzones)
				signal_noise = fltarr(self.nzones)
				for z = 0, self.nzones-1 do begin
				    this_sig = spec(z,*) ;- min(spec(z,*))
				    noise = n_elements(this_sig)*min(smooth(this_sig,7))
				    bgnd  = bgnd + noise
				    signal = signal + total(this_sig) - noise
				    ;print, "this sig", total(this_sig), "min was", min(spec(z,*))
					;signal = signal + total(spec(z,*)); - min(smooth(spec(z,*),5)))
					power = (abs(fft(this_sig)))^2
					signal_noise(z) = power(1)/median(power((self.nchann*3./8.):self.nchann/2.))
					zone_power[z] = power[1]
				endfor

			;\\ Update the signal_noise_history array
				ave_signal_noise = median(signal_noise)
				min_signal_noise = min(signal_noise)
				last_history = where(self.signal_noise_history eq 0)
				if n_elements(last_history) eq 1 then last_history = 0 else last_history = last_history(0)
				self.signal_noise_history(last_history) = ave_signal_noise
				self.scan_background_history[self.nscans - 1] = stddev(self.channel_background_history[0:self.nchann-1])

			;\\ If doing green, update the snr/scan value in the console
				if self.wavelength eq 557.7 then begin
					self.console->set_snr_per_scan, ave_signal_noise/float(self.nscans)
				endif

				time_elapsed = (dt_tm_tojs(systime(/ut)) - self.scan_start_time)
				signal = (signal / time_elapsed)/n_elements(image)
				bgnd = (bgnd / time_elapsed)/n_elements(image)

			;\\ Set exposure finished conditions - min 2 scans, etc.
				exp_finished = 0
				if self.nscans ge 2 and (min_signal_noise ge 1000 or ave_signal_noise ge 1500) then exp_finished = 1
				if time_elapsed gt 600 then exp_finished = 1
				if (min_signal_noise gt 15000) and (self.nscans ge 2) then exp_finished = 1

			;\\ Lasers only need the one scan however
				if self.wavelength eq 543.5 or self.wavelength eq 632.8 then begin
					if self.nscans gt 0 and ave_signal_noise lt 1500 then begin
				       self.scanning = 0
				       self.console->shutdown_spex
				       cmd = 'start "Restarting Observations" "c:\users\sdi3000\watchdog\restart_sdi3000_obs.bat" '
				       spawn, cmd
				    endif
					if self.nscans ge 1 and ave_signal_noise ge 50000 then exp_finished = 1
				endif

			;\\ If the finalize flag is set, end the exposure
				if self.finalize_flag eq 1 then exp_finished = 1

				load_pal, self.palette

			;\\ Plot snr history
				!p.multi=0
				!p.position=0
				exp_win_val = widget_info(self.id, find_by_uname='Spectrum_'+self.obj_num+'_exp_draw')
				widget_control, get_value=exp_win_id, exp_win_val
				wset, exp_win_id

				colors = intarr(last_history+1)
				colors(*) = self.palette.white
				if last_history gt 0 then begin
					plot, self.signal_noise_history(0:last_history), col = self.palette.white, back = self.palette.black, $
						  title = 'Signal/Noise History', xtitle = 'Scan #', ytitle = 'Signal/Noise', xtickint=1
				endif

			;\\ Plot background history
				bck_win_val = widget_info(self.id, find_by_uname='Spectrum_'+self.obj_num+'_bck_draw')
				widget_control, get_value=bck_win_id, bck_win_val
				wset, bck_win_id
				plot, self.scan_background_history[0:self.nscans - 1], xtickint=1, xtitle='Scan #', ytitle='Sttdev Bckgrnd / Power'


			!p.multi = [0,1,self.nzones]
			zcs = *self.zone_centers

			acc_im = *self.accumulated_image
			zon_bn = *self.zonemap_boundaries

			acc_im = bytscl(acc_im)
			acc_im(where(zon_bn eq 1)) = 255

			loadct, 0, /silent
			wset, tv_id
			x_corner = (552-self.xdim)/2
			y_corner = (552-self.ydim)/2
			imord = sort(acc_im)
			minb = acc_im(imord(0.005*n_elements(imord)))
			maxb = acc_im(imord(0.958*n_elements(imord)))
			tv, self.palette.imgmin + bytscl(acc_im, min=minb, max=maxb, top=self.palette.imgmax - self.palette.imgmin-1), x_corner, y_corner
			load_pal, self.palette

			case self.wavelength of

				630.0 : color = self.palette.red
				632.8 : color = self.palette.yellow
				543.5 : color = self.palette.yellow
				557.7 : color = self.palette.green
				589.0 : color = self.palette.orange
				732.0 : color = self.palette.rose

				else : color = self.palette.white

			endcase

			sumspec = median(total(spec, 1), 3)
			pk = where(sumspec eq max(sumspec))
			pk = pk(0)
			!p.noerase = 1
			for c = 0, self.nzones-1 do begin
				xc = zcs(c,0)
				yc = zcs(c,1)
				!p.position = [xc-20+x_corner,yc-20+y_corner,xc+20+x_corner,yc+20+y_corner]
				plot,  shift(spec(c,*)-min(spec(c,*)), nsteps/2 - pk), color = self.palette.white, xstyle=9, ystyle=4, thick=3, /device, /nodata, xtickname=strarr(10)+' '
				oplot, shift(spec(c,*)-min(spec(c,*)), nsteps/2 - pk), color = color, thick=6, psym = 3, symsize = 20
			endfor
			!p.noerase = 0
			!p.multi = 0

			js2ymds, self.scan_start_time, y, m, d, s
			hours = s /3600.
			mins = (hours mod 1) * 60.
			secs = (mins mod 1) * 60.
			time_str = string(hours, f='(i0)') + ':' + string(mins, f='(i0)') + ':' + string(secs, f='(i0)')
			xyouts, /normal, .04, .93, 'Start: ' + time_str, color=self.palette.white
			xyouts, /normal, .96, .93, 'Exposure: ' + strcompress(string(time_elapsed/60., format='(f4.1)'), /remove_all) + ' min', align=1
			xyouts, /normal, .04, .09, 'Scans: ' + strcompress(string(self.nscans,f='(i0)'), /remove), color=self.palette.white
			xyouts, /normal, .04, .05, 'Median SNR: ' + strcompress(string(ave_signal_noise,f='(i10)'), /remove), color=self.palette.white
			xyouts, /normal, .96, .05, 'Brite: ' + strcompress(string(signal, format='(f10.1)'), /remove), color=self.palette.white, align=1.
			xyouts, /normal, .96, .09, 'Bgnd: ' + strcompress(string(bgnd, format='(f10.1)'), /remove), color=self.palette.white, align=1.
			xyouts, /normal, .50, .96, '!5S!3', charsize = 1.5, charthick = 2, color=self.palette.white, align=0.5
			xyouts, /normal, .50, .01, '!5N!3', charsize = 1.5, charthick = 2, color=self.palette.white, align=0.5
			xyouts, /normal, .02, .50, '!5W!3', charsize = 1.5, charthick = 2, color=self.palette.white, align=0.5
			xyouts, /normal, .98, .50, '!5E!3', charsize = 1.5, charthick = 2, color=self.palette.white, align=0.5
			empty

			if exp_finished eq 1 then begin

				spec_save_info = self.console -> get_spec_save_info(self.nrings)
				ncdf_close, self.file_id
				free_lun, self.file_id
				end_time = dt_tm_tojs(systime(/ut))
				Write_Spectra_NetCDF, self.file_id, *self.spectra, self.scan_start_time, end_time, $
									  self.nscans, *self.accumulated_image, data=spec_save_info, $
									  fname=self.spec_path + self.filename, return_id=return_id, /update


				;\\ New - write out a snapshot into an IDL save file, and FTP
					header = self.console -> get_header_info()
					snapshot = {spectra:*self.spectra, $
								start_time:self.scan_start_time, $
								end_time:end_time, $
								scans:self.nscans, $
								rads:*self.rads, $
								secs:*self.secs, $
								wavelength:self.wavelength * 10, $
								site_code:header.site_code}

					log_dir = (self.console->get_logging_info()).log_directory
					if strmid(log_dir, strlen(log_dir)-1, strlen(log_dir)) ne '\' then log_dir += '\'
					save_name = log_dir + header.site_code + '_snapshot.idlsave'
					save, filename = save_name, snapshot, /compress
					openw, hnd, 'c:\users\sdi3000\ftp_snapshot.bat', /get
					printf, hnd, 'put ' + save_name
					printf, hnd, 'exit'
					free_lun, hnd
					spawn, 'c:\users\sdi3000\bin\psftp.exe 137.229.27.190 -l instrument -pw aer0n0my -b ' + $
						   'c:\users\sdi3000\ftp_snapshot.bat', /nowait, /hide
				;\\ -----------------------------------------------------------------------------------------


				self.file_id = return_id
				self.finalize_flag = 0
				self.scanning = 0
				self.nscans   = 0
				*self.spectra = ulonarr(self.nzones, self.nchann)
				if self.auto eq 1 then self.console -> end_auto_object, self.id, self

			endif else begin

				;\\ Restart the scanner
					self.console -> scan_etalon, 'Spectrum obj:'+self.obj_num, status = status, $
					     			wavelength=self.wavelength,  /start_scan
					self.scanning = 1
			endelse


		endif


	endif

EXIT_FRAME_PROCESSING:
end


;\\ Stop the procedure

pro SDISpectrum::stop_scan, event

	if self.scanning eq 1 then begin
		self.scanning = 0
		self.console -> scan_etalon, 'Spectrum (' + string(self.wavelength, f='(f0.1)') + ') obj:' + self.obj_num, $
						/stop_scan

		self.log -> update, 'Spectrum stopped'

		*self.spectra = ulonarr(self.nzones, self.nchann)

		if self.auto eq 1 then self.console -> end_auto_object, self.id, self

	endif

end


;\\ Finalize the current scan
pro SDISpectrum::finalize_scan, event
	self.finalize_flag = 1
end


;\\ Reloads the phasemap - if console refreshes the phasemap during the night,
;\\ this plugin needs to reload it and also reload it's zone settings with
;\\ the new fringe center (it might have changed)

pro SDISpectrum::set_phasemap, failed

	failed = 0

	self.log -> update, 'Setting/Refreshing Phasemap and Zones...'

	*self.phasemap = intarr(self.xdim, self.ydim)

	;\\ Get the phasemap if it exists in the console
		self.console -> get_phasemap, base, grad, lambda

	;\\ Interpolate to self.wavelength
		;phmap = float(base) + (float(grad) * (self.wavelength - lambda))
		phmap = float(base) * (lambda/self.wavelength) * grad
		*self.phasemap = fix(phmap)

		pmap = *self.phasemap
		wavelength = self.wavelength

		save, filename = 'c:\one.dat', pmap, base, grad, lambda, wavelength

		self -> initializer

end


;\\ Retrieves the objects structure data for restoring, so only needs save info (required)

function SDISpectrum::get_settings

	struc = {id:self.id, geometry:self.geometry, need_timer:self.need_timer, need_frame:self.need_frame}

	return, struc

end


;\\ Cleanup routine

pro SDISpectrum::cleanup, log

	if self.scanning eq 1 then self -> stop_scan, 0
	ptr_free, self.spectra, self.zonemap, self.phasemap, self.zone_centers
	ncdf_close, self.file_id

end

pro SDISpectrum__define

	void = {SDISpectrum, id:0L, $
						 scanning:0, $
						 nchann:0, $
						 xdim:0, $
						 ydim:0, $
						 save_file_id:0, $
						 spectra:ptr_new(/alloc), $
						 zonemap:ptr_new(/alloc), $
						 zonemap_boundaries:ptr_new(/alloc), $
						 phasemap:ptr_new(/alloc), $
						 signal_noise_history:fltarr(100), $
						 channel_background_history:fltarr(200), $
						 scan_background_history:fltarr(100), $
						 zone_centers:ptr_new(/alloc), $
						 nzones:0, $
						 dll:'', $
						 nscans:0, $
						 file_id:0, $
						 zone_settings:'', $
						 wavelength:0.0, $
						 A:0., $
						 B:0., $
						 C:0., $
						 scan_start_time:0D, $
						 spec_path:'', $
						 nrings:0, $
						 file_name_format:'', $
						 filename:'', $
						 rads:ptr_new(/alloc), $
						 secs:ptr_new(/alloc), $
						 accumulated_image:ptr_new(/alloc), $
						 finalize_flag:0, $
						 inherits XDIBase}


end