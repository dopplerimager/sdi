

function SDIPhaseMapper::init, restore_struc = restore_struc, data = data


	;\\ Generic Settings
		self.need_timer = 0
		self.need_frame = 1
		self.manager 	= data.manager
		self.console 	= data.console
		self.palette	= data.palette
		self.obj_num 	= string(data.count, format = '(i0)')

	;\\ Plugin Specific Settings
		self.nchann = data.nchann
		self.phasemap = ptr_new(/alloc)
		self.source_pmap = ptr_new(/alloc)
		self.image = ptr_new(/alloc)
		self.p = ptr_new(/allocate_heap)
		self.q = ptr_new(/allocate_heap)
		self.xdim = data.xdim
		self.ydim = data.ydim
		self.log = obj_new('XDILog', show_log = 0, prog_name = 'PhaseMapper', log_path = data.logging.log_directory, $
							enabled = data.logging.enable_logging, log_append = data.logging.log_append, header=data.header)

		;\\ Gain and exptime are only used when running in auto mode, and these values are supplied
		;\\ by the schedule file. In manual mode, the current values are used.
			self.gain = 0
			self.exptime = 0.1

		self.smooth_window = 0

		if data.recover eq 1 then begin
			;\\ Saved settings
				self.nscans = 1
				self.start_volt_offset = restore_struc.start_volt_offset
				self.stop_volt_offset  = restore_struc.stop_volt_offset
				self.volt_step_size    = restore_struc.volt_step_size
				self.source_order	   = restore_struc.source_order
				self.source_lambda	   = restore_struc.source_lambda
				xs 	= 512
				ys 	= 590
				xoff = restore_struc.geometry.xoffset
				yoff = restore_struc.geometry.yoffset
		endif else begin
			;\\ Default settings
				self.nscans = 1
				self.start_volt_offset = 1400
				self.stop_volt_offset  = 1600
				self.volt_step_size    = 10
				xoff = 0
				yoff = 0
				xs = 512
				ys = 590
		endelse


	base = widget_base(group_leader = data.leader, mbar = menu, xsize = xs, ysize = ys, xoff = xoff, yoff = yoff, $
					   title = 'SDI Phase Mapper')

	file_menu = widget_button(menu, value = 'File')

	self.id = base

	widget_control, base, /realize

	self.start_volt_offset = 0
	self.stop_volt_offset = fix(self.nchann * self.volt_step_size)

	font = 'TimesBold*22'
	font2 = 'TimesBold*18'

	draw = widget_draw(base, xs=xs, ys=512, uname = 'Phase_'+self.obj_num+'_draw')

	file_menu1 = widget_button(file_menu, value = 'Set Interp Parameters', uval = {tag:'set_interp'})
	file_menu2 = widget_button(file_menu, value = 'Set Smooth Window', uval = {tag:'set_smooth_window'})
	file_menu2 = widget_button(file_menu, value = 'Capture Image (.PNG)', uval = {tag:'image_capture', id:[draw], name:['Phase Map'], type:'png'})
	file_menu3 = widget_button(file_menu, value = 'Capture Image (.JPG)', uval = {tag:'image_capture', id:[draw], name:['Phase Map'], type:'jpg'}, $
								uname = 'Phasemapper_'+self.obj_num+'_jpg')


	chann_box = widget_text(base, yo = 535, xo = 260, value = 'Channel: '+string(self.channel,f='(i0)'), uname = 'Phase_'+self.obj_num+'_channel', font=font2, xs=12)
	scan_box  = widget_text(base, yo = 535, xo = 400, value = 'Scan: '+string(self.current_scan,f='(i0)'), uname = 'Phase_'+self.obj_num+'_scan', font=font2, xs=9)

	start_but = widget_button(base, value = 'Start Scan', yo = 530, xo = 10,  uval = {tag:'start_scan'}, font=font)
	stop_but  = widget_button(base, value = 'Stop Scan',  yo = 530, xo = 130, uval = {tag:'stop_scan'},  font=font)

	widget_control, base, /realize

	return, 1

end


pro SDIPhaseMapper::set_interp, event

	o = self.source_order
	xvaredit, o, name='Set Source Order', group = self.id
	self.source_order = o

	s = self.source_lambda
	xvaredit, s, name='Set Source Wavelengths (nm)', group = self.id
	self.source_lambda = s

end

pro SDIPhaseMapper::set_smooth_window, event

	o = self.smooth_window
	xvaredit, o, name='Set Smooth Window', group = self.id
	self.smooth_window = o

end


;\\ Start the procedure

pro SDIPhaseMapper::start_scan, event

	if self.scanning ne 1 then begin

		while self.source_lambda(0) eq 0.0 or self.source_lambda(1) eq 0.0 do begin
			s = self.source_lambda
			xvaredit, s, name='Cant Map Lambda = 0! Set New Source Wavelengths (nm)', group = self.id
			self.source_lambda = s
		endwhile

		*self.phasemap = intarr(self.xdim, self.ydim, self.nscans)
		*self.source_pmap = intarr(2, self.xdim, self.ydim)
		*self.image = uintarr(self.xdim, self.ydim, self.nchann)
		*self.p = fltarr(self.xdim, self.ydim)
		*self.q = fltarr(self.xdim, self.ydim)
		self.current_source = 0

		;\\ Set appropriate gain (this should be made configurable!!) 14/2/07
			;case self.source_lambda(self.current_source) of
			;	632.8: gain = 200
			;	543.5: gain = 200
			;	else : gain = 200
			;endcase
			;self.console -> cam_gain, 0, new_gain = gain

		;\\ Select the calibration source
		self.console -> mot_sel_cal, self.source_order(self.current_source)

		self.console -> scan_etalon, 'PhaseMapper obj:' + self.obj_num, /start_scan, status = status, wavelength = self.source_lambda(self.current_source)

		if status eq 'Scanner started' then begin
			self.scanning = 1
			self.log -> update, 'Started phasemapping @ ' + string(self.source_lambda(self.current_source), f='(f0.1)') + 'nm'
			self.log -> update, 'Source no: 1'
		endif

	endif

end


;\\ Auto-start the procedure

function SDIPhaseMapper::auto_start, args

	if n_elements(args) ne 7 then return, 'Error: wrong # of arguments'

	;\\ Make sure shutter is open and mirror is selecting lasers
		self.console -> cam_shutteropen, 0
		self.console -> mot_drive_cal, 0

	self.auto = 1
	;self.wavelength = float(args(0))
	self.source_order(0) = args(0)
	self.source_order(1) = args(1)
	self.source_lambda(0) = float(args(2))
	self.source_lambda(1) = float(args(3))
	self.gain = float(args(4))
	self.exptime = float(args(5))
	self.smooth_window = float(args(6))

	*self.phasemap = intarr(self.xdim, self.ydim, self.nscans)
	*self.source_pmap = intarr(2, self.xdim, self.ydim)
	*self.image = uintarr(self.xdim, self.ydim, self.nchann)
	*self.p = fltarr(self.xdim, self.ydim)
	*self.q = fltarr(self.xdim, self.ydim)
	self.current_source = 0

	;\\ Set appropriate gain (this should be made configurable!!) 14/2/07
		;case self.source_lambda(self.current_source) of
		;	632.8: gain = 200
		;	543.5: gain = 200
		;	else : gain = 200
		;endcase
		self.console -> cam_gain, 0, new_gain = self.gain
		self.console -> cam_exptime, 0, new_time = self.exptime


	;\\ Select the calibration source
	self.console -> mot_sel_cal, self.source_order(self.current_source)

	self.console -> scan_etalon, 'PhaseMapper obj:' + self.obj_num, /start_scan, status = status, $
								 wavelength = self.source_lambda(self.current_source)


	if status eq 'Scanner started' then begin
		self.scanning = 1
		self.log -> update, 'Auto-Started phasemapping @ ' + string(self.source_lambda(self.current_source), f='(f0.1)')
		self.log -> update, 'Source no: 0'
	endif else begin
		;\\ Update the log
			self.log -> update, 'Scanner could not be started - auto-mode'
			return, 'Error: failed to start scanner'
	endelse

	return, 'Success'

end


;\\ Frame Event

pro SDIPhaseMapper::frame_event, image, channel
    now = systime(1)

	scan = self.current_scan

	if self.scanning eq 1 then begin

		self.channel = channel

		;\\ Display properties and updates
			tv_id = widget_info(self.id, find_by_uname = 'Phase_'+self.obj_num+'_draw')
			chann_id = widget_info(self.id, find_by_uname = 'Phase_'+self.obj_num+'_channel')
			scan_id  = widget_info(self.id, find_by_uname = 'Phase_'+self.obj_num+'_scan')

			widget_control, get_value = draw_id, tv_id
			geom = widget_info(tv_id, /geom)
			wset, draw_id

			widget_control, set_value = 'Channel: '+string(channel, f='(i0)'), chann_id
			widget_control, set_value = 'Scan: '+string(scan, f='(i0)'), scan_id


		;\\ Store the latest image
;		    print, "Begin image store: ", systime(1) - now

;			images = *self.image
;			images(*,*,channel) = images(*,*,channel) + image
;			*self.image = images

			parr = *self.p
			qarr = *self.q

;		    print, "Begin trig: ", systime(1) - now
			parr = parr + (image * sin((2*!pi*float(channel))/float(self.nchann-1)))
			qarr = qarr + (image * cos((2*!pi*float(channel))/float(self.nchann-1)))

			*self.p = parr
			*self.q = qarr
			tvlct, fltarr(256), fltarr(256), findgen(256)

;			farr = bytscl(congrid((atan(*self.p, *self.q)) / (2*!pi), geom.xsize, geom.ysize))
			farr = bytscl(atan(*self.p, *self.q) / (2*!pi))
			tvscl, farr


			;\\ This stuff displays the zonemap next to the fringes in a sequence and saves them
			;window, 11, xsize = 512, ysize = 256
			;tvscl, congrid(farr, 256, 256)
			;loadct, 0, /silent
			;tvscl, congrid(image,256,256), 256, 0
			;pic = tvrd(/true)
			;write_jpeg, 'C:\Documents and Settings\Administrator\Desktop\object\MawsonCode\ScreenCaps\pic'+$
			;			string(channel,f='(i3.3)')+'.jpg', pic, /true, quality = 100

			load_pal, self.palette

		;\\ If last channel, make final array

			if channel eq (self.nchann-1) then begin

				farr = (atan(*self.p, *self.q) + !pi) / (2*!pi)
				farr = farr/max(farr)
				farr = farr * (self.nchann - 1)
				farr = fix(farr)

				tvlct, fltarr(256), fltarr(256), findgen(256)
				tvscl, bytscl(congrid(farr, geom.xsize, geom.ysize))
				load_pal, self.palette

				*self.p = fltarr(self.xdim, self.ydim)
				*self.q = fltarr(self.xdim, self.ydim)

				if scan eq (self.nscans-1) then begin
					path = self.console -> get_phase_map_path()
					base = self.console -> get_time_name_format()

					phase_map = farr

					;\\ Find the center
						;find_center, phase_map, self.xdim, self.ydim, draw=1, tv_id=draw_id, fxcen, fycen
						;self.console -> set_center, fxcen, fycen
						;self.console -> save_current_settings

					;\\ Unwrap the phasemap
						threshold = 80
						radial_chunk = 50
						fxcen = 256
						fycen = 256
						phasemap = phasemap_unwrap(fxcen, fycen, radial_chunk, self.nchann, threshold, 0, phase_map, /show, tv_id=draw_id)
						phasemap = smooth(phasemap, self.smooth_window, /edge_truncate)

						map = *self.source_pmap
						map(self.current_source,*,*) = phasemap
						*self.source_pmap = fix(map)

						p = fix(map)
						fname = 'c:\pmap' + string(self.current_source,f='(i0)') + '.dat'
						save, file=fname, p

					;\\ Store it in the console
					;	self.console -> set_phasemap, phasemap   \\\\ 9/2/07 Phasemap interpolation

					;\\ Save it in the console
					;	self.console -> save_current_settings	 \\\\ 9/2/07 Phasemap interpolation

					;	self.log -> update, 'Console phasemap updated'

					;\\ Save unwrapped version
						;save, filename = path + 'Phasemap ' + string(self.wavelength,f='(f0.1)') + ' ' + base + ' unwrapped.dat', p

						self.log -> update, 'Saved: ' + path + 'Phasemap ' + string(self.wavelength,f='(f0.1)') + ' ' + base + ' unwrapped.dat'

					;\\ Show it
						loadct, 0, /silent
						wset, draw_id
						tvscl, phasemap
						load_pal, self.palette

					;\\ Save the wrapped version
						phasemap = phase_map
						;save, filename = path + 'Phasemap ' + string(self.wavelength,f='(f0.1)') + ' ' + base + ' wrapped.dat', phasemap

						self.log -> update, 'Saved: ' + path + 'Phasemap ' + string(self.wavelength,f='(f0.1)') + ' ' + base + ' wrapped.dat'


					;\\ Update all active spectrum plugins
					;	struc = self.manager -> generate_list()
					;	specs = where(strmid(strlowcase(struc.type),0,8) eq 'spectrum', nspecs)
					;	if nspecs gt 0 then begin
					;		failed = 0
					;		for n = 0, nspecs - 1 do struc.ref(specs(n)) -> set_phasemap, failed
					;	endif

					;\\ Refresh spectrum phasemaps (and zonemaps)
					;	self.log -> update, 'Refreshing Spectrum Phasemaps...'
					;	self.console -> refresh_spec_pmaps

					;\\ If in auto mode, tell the console to end this plugin
					;	if self.auto eq 1 then self.console -> end_auto_object, self.id, self, /kill

					;	self.scanning = 0

				endif else begin

					self.scanning = 0

					self.console -> scan_etalon, 'PhaseMapper obj:' + self.obj_num, /start_scan, status = status, $
												  wavelength = self.wavelength

					if status eq 'Scanner started' then begin
						self.scanning = 1
						self.current_scan = self.current_scan + 1
						self.log -> update, 'Scan no: ' + string(self.current_scan+1, f='(i0)')
					endif

				endelse

				;\\ If current_source is 0, then do source 1, else do the interpolation
				if self.current_source eq 0 then begin

					self.current_source = self.current_source + 1

					;\\ Set appropriate gain (this should be made configurable!!) 14/2/07
					;case self.source_lambda(self.current_source) of
					;	632.8: gain = 200
					;	543.5: gain = 200
					;	else : gain = 200
					;endcase

					if self.auto eq 1 then begin
						self.console -> cam_gain, 0, new_gain = self.gain
						self.console -> cam_exptime, 0, new_time = self.exptime
					endif

					self.console -> mot_sel_cal, self.source_order(self.current_source)

					self.console -> scan_etalon, 'PhaseMapper obj:' + self.obj_num, /start_scan, status = status, $
												  wavelength = self.source_lambda(self.current_source)

					if status eq 'Scanner started' then begin
						self.scanning = 1
						self.log -> update, 'Auto-Started phasemapping @ ' + string(self.wavelength, f='(f0.1)')
						self.log -> update, 'Source no: 1'
					endif

				endif else begin

					l0 = self.source_lambda(0)
					l1 = self.source_lambda(1)

					pmaps = *self.source_pmap
					pmap0 = reform(pmaps(0,*,*))
					pmap1 = reform(pmaps(1,*,*))

					if l0 gt l1 then begin
						grad = (float(pmap0)/float(pmap1)) / (l1/l0)
						base = pmap1
						lambda = l1

					;	delta_l = l0 - l1
					;	grad    = (pmap0 - pmap1) / delta_l
					;	lambda  = l1
					;	base    = pmap1
					endif
					if l0 lt l1 then begin
						grad = (float(pmap1)/float(pmap0)) / (l0/l1)
						base = pmap0
						lambda = l0

					;	delta_l = l1 - l0
					;	grad    = (pmap1 - pmap0) / delta_l
					;	lambda  = l0
					;	base    = pmap0
					endif
					if l0 eq l1 then begin
					   grad = fltarr(n_elements(pmap0(*,0)),n_elements(pmap0(0,*))) + 1.
					   base = (pmap0+pmap1)/2
					   lambda = l0
					endif

					self.console -> set_phasemap, base, grad, lambda
					date_str = self.console -> get_time_name_format()

					;\\ Save the data
					save, filename = path + 'Phasemap ' + date_str + ' unwrapped.dat', base, grad, lambda

					self.console -> save_current_settings
					self.current_scan = 0
					self.scanning = 0

					if self.auto eq 1 then self.console -> end_auto_object, self.id, self, /kill

				endelse


			endif

	endif

end



;\\ Stop the procedure

pro SDIPhaseMapper::stop_scan, event

	if self.scanning eq 1 then begin
		self.scanning = 0
		self.console -> scan_etalon, 'Phasemapper obj:' + self.obj_num, /stop_scan


		self.log -> update, 'Phasemapper stopped'
		self.current_scan = 0
		*self.phasemap = intarr(self.xdim, self.ydim, self.nscans)
		*self.image = uintarr(self.xdim, self.ydim, self.nchann)
		*self.p = fltarr(self.xdim, self.ydim)
		*self.q = fltarr(self.xdim, self.ydim)

		if self.auto eq 1 then self.console -> end_auto_object, self.id, self, /kill

	endif

end


;\\ Retrieves the objects structure data for restoring, so only needs save info (required)

function SDIPhaseMapper::get_settings

	struc = {id:self.id, nscans:self.nscans, start_volt_offset:self.start_volt_offset, stop_volt_offset:self.stop_volt_offset, $
			 volt_step_size:self.volt_step_size, source_order:self.source_order, source_lambda:self.source_lambda, $
			 geometry:self.geometry, need_timer:self.need_timer, need_frame:self.need_frame}

	return, struc

end

;\\ Cleanup routine

pro SDIPhaseMapper::cleanup, log

	ptr_free, self.image, self.phasemap, self.p, self.q
	;self.current_scan = 0
	;*self.phasemap = intarr(self.xdim, self.ydim, self.nscans)
	;*self.image = uintarr(self.xdim, self.ydim, self.nchann)
	;*self.p = fltarr(self.xdim, self.ydim)
	;*self.q = fltarr(self.xdim, self.ydim)

	if self.auto eq 1 then self.console -> end_auto_object, self.id, self, /kill
	if self.scanning eq 1 then begin
		self.scanning = 0
		self.console -> scan_etalon, 'Phasemapper obj:' + self.obj_num, /stop_scan
	endif

end

pro SDIPhaseMapper__define

	void = {SDIPhaseMapper, id:0L, nscans:0, current_scan:0, scanning:0, nchann:0, wavelength:0.0, $
			start_volt_offset:0, stop_volt_offset:0, volt_step_size:0.0, channel:0, $
			image:ptr_new(/alloc), phasemap:ptr_new(/alloc), xdim:0, ydim:0, leg1:0, leg2:0, leg3:0, $
			leg1l:0, leg2l:0, leg3l:0, chord:0.0, p:ptr_new(/alloc), q:ptr_new(/alloc), $
			source_order:intarr(2), source_lambda:fltarr(2), source_pmap:ptr_new(/alloc), $
			current_source:0, gain:0., exptime:0., smooth_window:0., inherits XDIBase}

end